<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css">
    <title>Book</title>
</head>

<body>
<div id="loading-bar-container">
  <div id="loading-bar"></div>
</div>
<div id="book-container" class="book-viewer"></div>
<div class="progress-container">
  <div>Title: <b>{{ book.title }}</b></div>
  <span id="current-page">Page: 1</span>
  <span id="percentage-progress">Completed: 0%</span>
  <button onclick="saveProgress()">Save Progress</button>
  <button id="toggle-dark-mode">Toggle Dark Mode</button>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.14.305/pdf.min.js"></script>
<script>

  document.addEventListener('DOMContentLoaded', () => {
      const bookUrl = "{{ book.pdf_loc }}";
      const bookContainer = document.getElementById('book-container');
      const currentPageSpan = document.getElementById('current-page');
      const percentageProgressSpan = document.getElementById('percentage-progress');
      const toggleDarkModeButton = document.getElementById('toggle-dark-mode');
      const loadingBarContainer = document.getElementById('loading-bar-container');
      const loadingBar = document.getElementById('loading-bar');
      
      let totalPages = 0;
      let currentPage = parseInt('{{ last_read_page }}') || 1;
      let isScrollingProgrammatically = false;

      // Check if we have a valid book URL
      if (!bookUrl || bookUrl === '') {
          loadingBarContainer.style.display = 'none';
          bookContainer.innerHTML = '<div style="padding: 20px; text-align: center; color: red;">Error: No book file specified.</div>';
          return;
      }

      // Load PDF
      setTimeout(() => {
          loadPdf();
      }, 100);

      function loadPdf() {

          const loadingTask = pdfjsLib.getDocument(bookUrl);
          loadingTask.onProgress = function (progressData) {
              const progress = (progressData.loaded / progressData.total) * 100;
              loadingBar.style.width = `${progress}%`;
          };

          loadingTask.promise.then(pdf => {
              // Hide the loading bar once the PDF is fully loaded
              loadingBarContainer.style.display = 'none';

              totalPages = pdf.numPages;
              let pagesRendered = 0;
              
              // Create page loading progress bar (matching button color)
              const pageLoadingBar = document.createElement('div');
              pageLoadingBar.id = 'page-loading-bar';
              pageLoadingBar.style.cssText = `
                  position: fixed;
                  top: 0;
                  left: 0;
                  width: 0%;
                  height: 5px;
                  background-color: #2c3e50;
                  z-index: 1002;
                  transition: width 0.3s ease;
              `;
              document.body.appendChild(pageLoadingBar);
              
              // Disable scrolling initially
              document.body.style.overflow = 'hidden';
              
              // Function to update page loading progress
              function updatePageLoadingProgress() {
                  const progress = (pagesRendered / totalPages) * 100;
                  pageLoadingBar.style.width = `${progress}%`;
                  
                  if (pagesRendered === totalPages) {
                      // All pages loaded - enable scrolling and set up observer
                      setTimeout(() => {
                          document.body.style.overflow = '';
                          pageLoadingBar.style.display = 'none';
                          setupPageObserver();
                      }, 500);
                  }
              }

              for (let pageNum = 1; pageNum <= totalPages; pageNum++) {
                  pdf.getPage(pageNum).then(page => {
                      const viewport = page.getViewport({ scale: 1.5 });

                      const canvas = document.createElement('canvas');
                      canvas.style.marginBottom = '20px';
                      canvas.style.display = 'block';
                      canvas.style.marginLeft = 'auto';
                      canvas.style.marginRight = 'auto';
                      canvas.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.1)';
                      canvas.style.borderRadius = '4px';
                      canvas.id = `page-${pageNum}`;
                      bookContainer.appendChild(canvas);

                      const context = canvas.getContext('2d');
                      canvas.width = viewport.width;
                      canvas.height = viewport.height;

                      const renderContext = {
                          canvasContext: context,
                          viewport: viewport,
                      };
                      
                      // Monitor when each page completes rendering
                      page.render(renderContext).promise.then(() => {
                          pagesRendered++;
                          updatePageLoadingProgress();
                      });
                  });
              }

              // Initial progress display
              updateProgressDisplay(currentPage, totalPages);

              // Function to set up page observer after all pages are rendered
              function setupPageObserver() {
                  let observer = null;
                  if ('IntersectionObserver' in window) {
                      observer = new IntersectionObserver((entries) => {
                          if (isScrollingProgrammatically) return;
                          
                          entries.forEach(entry => {
                              if (entry.isIntersecting) {
                                  const pageId = entry.target.id;
                                  const pageNumber = parseInt(pageId.replace('page-', ''));
                                  
                                  if (pageNumber && pageNumber !== currentPage) {
                                      currentPage = pageNumber;
                                      updateProgressDisplay(currentPage, totalPages);
                                  }
                              }
                          });
                      }, {
                          root: null,
                          rootMargin: '-30% 0px -30% 0px',
                          threshold: 0.2
                      });

                      // Set up intersection observer for all pages (now guaranteed to be rendered)
                      for (let i = 1; i <= totalPages; i++) {
                          const page = document.getElementById(`page-${i}`);
                          if (page) {
                              observer.observe(page);
                          }
                      }
                  }

                  // Scroll to the last read page after observer setup
                  setTimeout(() => {
                      isScrollingProgrammatically = true;
                      
                      const targetCanvas = document.getElementById(`page-${currentPage}`);
                      if (targetCanvas) {
                          targetCanvas.scrollIntoView({ behavior: 'instant', block: 'start' });
                      }
                      
                      // Re-enable detection after scroll completes
                      setTimeout(() => {
                          isScrollingProgrammatically = false;
                      }, 300);
                  }, 100);
              }

              // Fallback for browsers without IntersectionObserver (if needed)
              if (!('IntersectionObserver' in window)) {
                  let lastScrollY = window.scrollY;
                  setInterval(() => {
                      if (isScrollingProgrammatically) return;
                      
                      const currentScrollY = window.scrollY;
                      if (Math.abs(currentScrollY - lastScrollY) > 50) {
                          lastScrollY = currentScrollY;
                          
                          // Simple detection: page 2 if scrolled more than 300px
                          const targetPage = currentScrollY > 300 && totalPages >= 2 ? 2 : 1;
                          if (targetPage !== currentPage) {
                              currentPage = targetPage;
                              updateProgressDisplay(currentPage, totalPages);
                          }
                      }
                  }, 200);
              }
          }).catch(error => {
              console.error('Error loading PDF:', error);
              loadingBarContainer.style.display = 'none';
              bookContainer.innerHTML = '<div style="padding: 20px; text-align: center; color: red;">Error loading PDF: ' + error.message + '</div>';
          });
      }

      function updateProgressDisplay(currentPage, totalPages) {
          if (totalPages > 0 && currentPage >= 1 && currentPage <= totalPages) {
              const progressPercentage = (currentPage / totalPages) * 100;
              currentPageSpan.textContent = `Page: ${currentPage}`;
              percentageProgressSpan.textContent = `Completed: ${progressPercentage.toFixed(2)}%`;
          }
      }

      window.saveProgress = function () {
          const currentPageText = currentPageSpan.textContent.split(': ')[1];
          const progressPercentageText = percentageProgressSpan.textContent.split(': ')[1].replace('%', '');

          if (totalPages > 0) {
              fetch('/api/progress', {
                  method: 'POST',
                  headers: {
                      'Content-Type': 'application/json',
                  },
                  body: JSON.stringify({
                      book_id: parseInt('{{ book.id }}'),
                      progress_percentage: parseFloat(progressPercentageText),
                      last_read_page: parseInt(currentPageText, 10)
                  }),
              })
              .then(response => response.json())
              .then(data => {
                  alert(data.message || 'Progress saved successfully!');
              })
              .catch(error => {
                  console.error('Error:', error);
                  alert('Failed to save progress.');
              });
          } else {
              alert('Total pages not loaded yet.');
          }
      };

      window.addEventListener('beforeunload', () => {
          saveProgress();
      });

      // Dark mode toggle
      toggleDarkModeButton.addEventListener('click', () => {
          document.body.classList.toggle('dark-mode');
      });
  });
</script>
<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  html, body {
    height: 100%;
    overflow-x: hidden; /* Prevent horizontal scrolling */
  }

  body {
    background-color: #f9f9f9;
    color: #333;
    font-family: Arial, sans-serif;
    transition: background-color 0.3s, color 0.3s;
  }

  body.dark-mode {
    background-color: #121212;
    color: #f9f9f9;
  }

  .book-info {
    text-align: center;
    font-weight: bold;
    font-size: 1.5rem;
    margin: 20px 0;
    padding: 1rem;
    background-color: #ffffff;
    border-radius: 8px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    transition: background-color 0.3s, color 0.3s;
  }

  body.dark-mode .book-info {
    background-color: #1e1e1e;
    color: #f9f9f9;
  }

  .progress-container {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 1rem;
    padding: 1rem;
    background-color: #ffffff;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    z-index: 1000;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  }

  body.dark-mode .progress-container {
    background-color: #1e1e1e;
    color: #f9f9f9;
  }

  .progress-container span {
    font-size: 1rem;
    white-space: nowrap;
  }

  .progress-container button {
    padding: 0.5rem 1rem;
    background-color: #2c3e50;
    color: #fff;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.3s;
    margin: 0 0.25rem;
    white-space: nowrap;
  }

  .progress-container button:hover {
    background-color: #34495e;
  }

  .progress-container button:disabled {
    background-color: #95a5a6;
    cursor: not-allowed;
  }

  body.dark-mode .progress-container button {
    background-color: #444;
    color: #f9f9f9;
  }

  body.dark-mode .progress-container button:hover {
    background-color: #555;
  }

  body.dark-mode .progress-container button:disabled {
    background-color: #666;
  }

  .book-viewer {
    margin-top: 80px; /* Account for fixed progress container */
    padding: 2rem 1rem;
    width: 100%;
    /* Ensure content flows naturally and creates scrollable page */
    overflow: visible;
  }

  /* PDF canvas styling */
  .book-viewer canvas {
    max-width: 100%;
    height: auto;
  }

  #loading-bar-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 5px;
    background-color: #f3f3f3;
    z-index: 1001;
  }

  #loading-bar {
    height: 100%;
    width: 0;
    background-color: #3498db;
    transition: width 0.2s ease;
  }

  /* Responsive design */
  @media (max-width: 768px) {
    .progress-container {
      flex-wrap: wrap;
      padding: 0.5rem;
      gap: 0.5rem;
    }
    
    .progress-container div,
    .progress-container span {
      font-size: 0.9rem;
    }
    
    .progress-container button {
      padding: 0.4rem 0.8rem;
      font-size: 0.9rem;
    }
    
    .book-viewer {
      margin-top: 100px; /* Slightly more space on mobile */
      padding: 1rem 0.5rem;
    }
  }
</style>
</body>

</html>